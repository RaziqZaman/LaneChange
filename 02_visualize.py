#!/usr/bin/env python3
"""Summarise lane-change neighbour roles into CSV and PNG summaries.

Reads ``outputs/01_events.csv`` (generated by ``01_measure.py``) and counts how
often each neighbouring role (LC, RC, LT, RT) is occupied by a human driver,
the autonomous vehicle, or nobody. Rows where the subject vehicle is the SDC or
where any neighbour lacks an ``*_is_SDC`` flag are ignored.

The resulting chart is written to ``outputs/02_counts.csv`` with five rows:
    * all neighbours are human drivers
    * exactly one of LC/RC/LT/RT is the autonomous vehicle (one row per role)

Additionally, a PNG image (``outputs/02_counts.png``) shows the 12 most
frequent human-only configurations and the 12 most frequent configurations
that include the autonomous vehicle.
"""

from __future__ import annotations

import argparse
import csv
from pathlib import Path
from typing import Dict, Iterable, List, Optional, Tuple

import matplotlib.pyplot as plt


DEFAULT_INPUT = Path("outputs/01_events.csv")
DEFAULT_OUTPUT = Path("outputs/02_counts.csv")
DEFAULT_FIGURE = Path("outputs/02_counts.png")

ROLE_NAMES = ("LC", "RC", "LT", "RT")
ROLE_COMBINATIONS = [
    ("Human Driver", "Human Driver", "Human Driver", "Human Driver"),
    ("Autonomous Vehicle", "Human Driver", "Human Driver", "Human Driver"),
    ("Human Driver", "Autonomous Vehicle", "Human Driver", "Human Driver"),
    ("Human Driver", "Human Driver", "Autonomous Vehicle", "Human Driver"),
    ("Human Driver", "Human Driver", "Human Driver", "Autonomous Vehicle"),
]

LABEL_ORDER = {
    "Autonomous Vehicle": 0,
    "Human Driver": 1,
    "Not Present": 2,
}

ABBREVIATIONS = {
    "Autonomous Vehicle": "AV",
    "Human Driver": "HD",
    "Not Present": "NP",
}


def _sort_key(combo: Tuple[str, str, str, str]) -> Tuple[int, Tuple[int, int, int, int]]:
    av_count = sum(1 for label in combo if label == "Autonomous Vehicle")
    label_key = tuple(LABEL_ORDER.get(label, 99) for label in combo)
    return (av_count, label_key)


def parse_flag(value: Optional[str]) -> Optional[int]:
    if value is None:
        return None
    raw = value.strip()
    if not raw:
        return None
    try:
        flag = int(float(raw))
    except ValueError:
        return None
    if flag not in (0, 1):
        return None
    return flag


def load_rows(path: Path) -> Iterable[Dict[str, str]]:
    with path.open("r", encoding="utf-8", newline="") as source:
        reader = csv.DictReader(source)
        for row in reader:
            yield row


def classify_roles(row: Dict[str, str]) -> Optional[Tuple[str, str, str, str]]:
    sv_flag = parse_flag(row.get("sv_is_SDC"))
    if sv_flag is None or sv_flag == 1:
        return None

    role_labels: list[str] = []
    av_count = 0

    for role in ROLE_NAMES:
        raw_value = row.get(f"{role.lower()}_is_SDC")
        if raw_value is None:
            return None
        raw_value = raw_value.strip()
        if raw_value == "":
            role_labels.append("Not Present")
            continue

        flag = parse_flag(raw_value)
        if flag is None:
            return None
        if flag == 1:
            av_count += 1
            role_labels.append("Autonomous Vehicle")
        else:
            role_labels.append("Human Driver")

    if av_count > 1:
        return None
    return tuple(role_labels)  # type: ignore[return-value]


def write_counts(path: Path, counts: Dict[Tuple[str, str, str, str], int]) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    sorted_combos = list(ROLE_COMBINATIONS)
    extra = sorted(
        [combo for combo in counts if combo not in ROLE_COMBINATIONS],
        key=_sort_key,
    )
    sorted_combos.extend(extra)
    with path.open("w", encoding="utf-8", newline="") as dest:
        writer = csv.writer(dest)
        writer.writerow(["LC", "RC", "LT", "RT", "Count"])
        for combo in sorted_combos:
            abbrev = [ABBREVIATIONS.get(label, label) for label in combo]
            writer.writerow([*abbrev, counts.get(combo, 0)])


def build_ranked_lists(
    counts: Dict[Tuple[str, str, str, str], int]
) -> Tuple[List[Tuple[str, str, str, str]], List[Tuple[str, str, str, str]]]:
    human_only = [
        combo for combo, cnt in counts.items() if cnt > 0 and "Autonomous Vehicle" not in combo
    ]
    human_av = [
        combo for combo, cnt in counts.items() if cnt > 0 and "Autonomous Vehicle" in combo
    ]
    human_only.sort(key=lambda combo: counts[combo], reverse=True)
    human_av.sort(key=lambda combo: counts[combo], reverse=True)
    return human_only[:12], human_av[:12]


def pad_table_rows(rows: List[List[str]], target: int) -> List[List[str]]:
    padded = list(rows)
    while len(padded) < target:
        padded.append([""] * 5)
    return padded


def pad_table_data(
    rows: List[List[str]],
    counts: List[int],
    target: int,
) -> Tuple[List[List[str]], List[Optional[int]]]:
    padded_rows = list(rows)
    padded_counts: List[Optional[int]] = list(counts)
    while len(padded_rows) < target:
        padded_rows.append(["", "", "", "", ""])
        padded_counts.append(None)
    return padded_rows, padded_counts


def create_tables(
    figure_path: Path,
    counts: Dict[Tuple[str, str, str, str], int],
) -> None:
    human_only, human_av = build_ranked_lists(counts)

    table_specs = [
        ("Top 12 Human-Only Configurations", human_only),
        ("Top 12 Human-AV Configurations", human_av),
    ]

    figure_path.parent.mkdir(parents=True, exist_ok=True)

    fig, axes = plt.subplots(1, 2, figsize=(12, 6))
    for ax, (title, combos) in zip(axes, table_specs):
        ax.axis("off")
        ax.set_title(title, fontsize=12, pad=4, fontweight="bold")

        rows: List[List[str]] = []
        count_values: List[int] = []
        for combo in combos:
            count = counts.get(combo, 0)
            row = [ABBREVIATIONS.get(label, label) for label in combo]
            row.append(str(count))
            rows.append(row)
            count_values.append(count)

        max_count = max(count_values) if count_values else 0
        rows, padded_counts = pad_table_data(rows, count_values, 12)

        table = ax.table(
            cellText=rows,
            colLabels=["LC", "RC", "LT", "RT", "Count"],
            cellLoc="center",
            loc="center",
        )
        table.scale(1.0, 1.6)
        table.auto_set_font_size(False)
        table.set_fontsize(10)

        cmap = plt.get_cmap("Greens")

        for (row_idx, col_idx), cell in table.get_celld().items():
            if row_idx == 0:
                cell.get_text().set_fontweight("bold")
                continue

            cell_text = cell.get_text()
            if col_idx < 4:
                label = rows[row_idx - 1][col_idx]
                if label == "AV":
                    cell.set_facecolor("#d4e6f8")
                elif label == "HD":
                    cell.set_facecolor("#f8d7da")
                elif label == "NP":
                    cell.set_facecolor("#f2f4f4")
                else:
                    cell.set_facecolor("#ffffff")
            else:
                count_value = padded_counts[row_idx - 1]
                if count_value is not None and max_count > 0:
                    norm = 0.15 + 0.55 * (count_value / max_count)
                    cell.set_facecolor(cmap(norm))
                    cell_text.set_fontweight("bold")
                else:
                    cell.set_facecolor("#e9f7ef")
                    cell_text.set_fontweight("bold")

    fig.tight_layout()
    fig.savefig(figure_path, dpi=200, bbox_inches="tight")
    plt.close(fig)


def main() -> None:
    parser = argparse.ArgumentParser(description="Generate neighbour role counts from 01_events.csv.")
    parser.add_argument("--input", type=Path, default=DEFAULT_INPUT, help="Path to 01_events.csv.")
    parser.add_argument("--output", type=Path, default=DEFAULT_OUTPUT, help="Destination CSV for the chart.")
    parser.add_argument("--figure", type=Path, default=DEFAULT_FIGURE, help="Destination PNG for the tables.")
    args = parser.parse_args()

    if not args.input.exists():
        raise SystemExit(f"Input CSV not found: {args.input}")

    counts: Dict[Tuple[str, str, str, str], int] = {}
    for row in load_rows(args.input):
        combo = classify_roles(row)
        if combo is None:
            continue
        counts[combo] = counts.get(combo, 0) + 1

    write_counts(args.output, counts)
    create_tables(args.figure, counts)


if __name__ == "__main__":
    main()
